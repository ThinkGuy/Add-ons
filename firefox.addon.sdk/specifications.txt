1.页面 mod ︰ 使您可以将内容脚本附加到特定的 URL 模式匹配的 web 页。

2.您可以通过将一个字符串数组传递给 contentScript 或 contentScriptFile 加载多个脚本 ︰

3.访问 DOM
内容的脚本可以访问 DOM 中的页面，当然，就像已加载页面 （页面脚本） 的任何脚本。但内容脚本绝缘从页面的脚本 ︰
内容脚本看不到任何 JavaScript 对象添加到页的脚本
如果页面脚本重新定义了一些 DOM 对象的行为，内容脚本会看到原来的行为。
这同样适用于反向 ︰ 页脚本不能看到由内容脚本添加 JavaScript 对象。

4.与页脚本交互
通常内容脚本和页面脚本之间的绝缘是你想要什么。但是有时你可能想要与页面脚本进行交互 ︰ 你可能想要内容脚本和页面脚本之间共享对象或者它们之间发送消息。如果您需要这样做，请阅读有关与页脚本交互。

//1
//page-mod 页面 mod ︰ 使您可以将内容脚本附加到特定的 URL 模式匹配的 web 页。

var pageMod = require("sdk/page-mod");

pageMod.PageMod({
  include: "*.mozilla.org",
  contentScriptFile: "./content-script.js"
});

//2
//您可以通过将一个字符串数组传递给 contentScript 或 contentScriptFile 加载多个脚本 ︰
//如果你这样做，脚本可以直接彼此交互，就像由相同的 web 页加载的脚本。

var data = require("sdk/self").data;
var pageMod = require("sdk/page-mod");

pageMod.PageMod({
  include: "*.mozilla.org",
  contentScriptFile: [data.url("jquery.min.js"), data.url("my-content-script.js")]


//3
//另一个脚本加载到页面后，此脚本将能够访问 foo。但内容的脚本不会 ︰
var tabs = require("sdk/tabs");
var mod = require("sdk/page-mod");
var self = require("sdk/self");

var pageUrl = self.data.url("page.html")

var pageMod = mod.PageMod({
  include: pageUrl,
  contentScript: "console.log(window.foo);"
})

tabs.open(pageUrl);

// 这里是简单的附加组件将消息发送到内容的脚本使用端口 ︰

var tabs = require("sdk/tabs");
var self = require("sdk/self");

tabs.on("ready", function(tab) {
  var worker = tab.attach({
    contentScriptFile: self.data.url("content-script.js")
  });
  worker.port.emit("alert", "Message from the add-on");
});

tabs.open("http://www.mozilla.org");



Add-on与content通讯
self.port.emit()   //send
self.port.on()     //receive


业务逻辑：
1.实时监控xueshu.baidu.com//
2.顺势弹出sidebar。				3.同时注入js获取content and url中的key
4.用户验证。request-response。   (clientConnectToserver())
5.将获取的content传至服务器。
6.服务器处理完之后传至sidebar display.


实现逻辑：

